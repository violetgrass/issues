@using Violet.WorkItems.Query
@inject IDialogService DialogService

@if (Query?.Clause is not null)
{
    <FluentTextField Value="" ReadOnly="@(!IsEditable)">
        @RenderClause(Query.Clause, IsEditable)
        @if (IsEditable)
        {
            <FluentIcon Value="@(new Icons.Regular.Size16.Add())" Slot="start" OnClick="OpenEditorAsync"/>
        }
    </FluentTextField>
}
else
{
    <text></text>
}

@code {
    [Parameter]
    public WorkItemsQuery? Query { get; set; } = null;
    [Parameter]
    public bool IsEditable { get; set; } = true;

    private async Task OpenEditorAsync()
    {
        DialogParameters<WorkItemsQuery> parameters = new()
        {
            Content = Query,
            Title = $"Edit Query",
            Alignment = HorizontalAlignment.Right,
            Modal = true,
            ShowDismiss = true,
            PrimaryAction = "Update",
            SecondaryAction = "Cancel",
            Width = "350px",
        };
        var dialog = await DialogService.ShowPanelAsync<WiqlPanel>(Query, parameters);
        var result = await dialog.Result;

        if (result.Data is WorkItemsQuery updatedQuery)
        {
            Query = updatedQuery;
            Console.WriteLine(Query);
        }
    }


    public static RenderFragment RenderClause(QueryClause clause, bool isEditable = false, bool isNegative = false)
    {
        var appearance = Appearance.Neutral;

        if (isEditable == false)
        {
            appearance = Appearance.Lightweight;
        }

        switch (clause)
        {
            case ProjectClause projectClause:
                return @<FluentBadge Tag="clause" Slot="start" style="margin-right:4px" Appearance="@appearance">Project: @projectClause.ProjectCode</FluentBadge>;
            case WorkItemIdClause idClause:
                return @<FluentBadge Tag="clause" Slot="start" style="margin-right:4px" Appearance="@appearance"># @idClause.WorkItemId</FluentBadge>;
            case WorkItemTypeClause typeClause:
                return @<FluentBadge Tag="clause" Slot="start" style="margin-right:4px" Appearance="@appearance">Type: @typeClause.WorkItemType</FluentBadge>;
            case AndClause andClause:
                return
    @<text>
        @foreach (var subClause in andClause.SubClauses)
    {
        @RenderClause(subClause, isEditable, isNegative)
    }
    </text>;
            case OrClause orClause:
                return
    @<text>
        OR (
        @foreach (var subClause in orClause.SubClauses)
    {
        @RenderClause(subClause, isEditable, isNegative)
    }
        )
    </text>;
            case NotClause notClause:
                return RenderClause(notClause.SubClause, !isNegative);
            case StringMatchClause stringMatch:
                return @<FluentBadge Tag="clause" Slot="start" style="margin-right:4px" Appearance="@appearance">@stringMatch.PropertyName | @stringMatch.Match</FluentBadge>;
            case ValueMatchClause valueMatch:
                return @<FluentBadge Tag="clause" Slot="start" style="margin-right:4px" Appearance="@appearance">@valueMatch.PropertyName | @string.Join(", ", valueMatch.Values)</FluentBadge>;
            default:
                return @<text>Fooo</text>;
        }

        return null;
    }
}