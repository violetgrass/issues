@using Violet.WorkItems.Query
@implements IDialogContentComponent<WorkItemsQuery>
@inject WorkItemDescriptorService WorkItemDescriptorService
@inject ValueProviderService ValueProviderService

<FluentDialogBody>
    <FluentAccordion>
        <FluentAccordionItem Heading="Filter" Expanded="true">
            <FluentIcon Value="@(new Icons.Regular.Size20.Filter())" Color="@Color.Neutral" Slot="start" />

            <FluentTreeView>
                @foreach (var clause in ((AndClause)Query.Clause).SubClauses)
                {
                    <FluentTreeItem>
                        @WiqlField.RenderClause(clause, true)
                        <FluentSpacer />
                        <FluentIcon Value="@(new Icons.Regular.Size16.Delete())" @onclick="@(_ => RemoveClauseAsync(clause))" />
                    </FluentTreeItem>
                }
            </FluentTreeView>

        </FluentAccordionItem>

        <FluentAccordionItem Heading="New Clause" Expanded="true">
            <FluentIcon Value="@(new Icons.Regular.Size20.FilterAdd())" Color="@Color.Neutral" Slot="start" />
            @if (editingClause is not null)
            {
                <FluentButton IconEnd="@(new Icons.Regular.Size16.ArrowLeft())" Appearance="Appearance.Stealth" Slot="end" OnClick="@(_ => editingClause = null)" />
            }

            <FluentStack Orientation="Orientation.Vertical">
                @code {
                    private QueryClause? editingClause = default;
                }

                @* Step One: Select the property *@
                @if (editingClause is null)
                {
                    <FluentListbox TOption="string" style="height:200px;">
                        @if (WorkItemTypes is not null && WorkItemDescriptor is null)
                        {
                            <FluentOption TOption="string" @onclick="@(_ => editingClause = new WorkItemTypeClause(""))" Value="property:WorkItemType">Type</FluentOption>
                        }
                        else if (WorkItemDescriptor is not null)
                        {
                            @foreach (var property in WorkItemDescriptor.Properties)
                            {
                                <FluentOption @onclick="@(async _ => { editingClause = new ValueMatchClause(property.Name, [ string.Empty ], false); await LoadValuesAsync(property.Name); })" Value="@("property:" + property.Name)">@property.Label</FluentOption>
                            }
                        }
                    </FluentListbox>
                }
                else
                {
                    @* Step One: Select a Value *@
                    if (editingClause is WorkItemTypeClause && WorkItemTypes is not null && WorkItemDescriptor is null)
                    {
                        <FluentListbox TOption="string">
                            @foreach (var type in WorkItemTypes)
                            {
                                <FluentOption TOption="string" @onclick="@(async _ => { await AddWorkItemTypeClauseAsync(ProjectCode, type.Name); editingClause = null; })" Value="@("type:" + type.Name)">@type.DisplayName</FluentOption>
                            }
                        </FluentListbox>
                    }
                    else if (editingClause is ValueMatchClause vmc)
                    {
                        if (ValuesForSelection is not null)
                        {
                            <FluentListbox TOption="string">
                                @foreach (var value in ValuesForSelection)
                                {
                                    <FluentOption TOption="string" @onclick="@(async _ => { await AddPropertyClauseAsync(vmc.PropertyName, value.Value); editingClause = null; })" Value="@("value" + value.Value)">@value.DisplayText</FluentOption>
                                }
                            </FluentListbox>
                        }
                    }
                }
            </FluentStack>
        </FluentAccordionItem>
        <FluentAccordionItem Heading="Recent Clauses" Expanded="true">
            <FluentIcon Value="@(new Icons.Regular.Size20.Star())" Color="@Color.Neutral" Slot="start" />
        </FluentAccordionItem>
    </FluentAccordion>
</FluentDialogBody>

<FluentDialogFooter>
    <FluentButton Appearance="Appearance.Accent" OnClick="OnUpdateAsync">Update</FluentButton>
</FluentDialogFooter>
@code {
    [Parameter]
    public WorkItemsQuery Content { get; set; } = default!;
    [CascadingParameter]
    public FluentDialog? Dialog { get; set; } = default!;
    public WorkItemsQuery Query { get; set; } = default!;
    private IEnumerable<Violet.WorkItems.Types.WorkItemType>? WorkItemTypes { get; set; }
    private Service.Messages.WorkItemDescriptorApiResponse? WorkItemDescriptor { get; set; } = null;
    public string? ProjectCode { get; set; } = null;
    public string? WorkItemType { get; set; } = null;
    public IEnumerable<ValueProvider.ProvidedValue>? ValuesForSelection { get; set; } = default;

    protected override async Task OnParametersSetAsync()
    {
        Query = Content;
        await ReloadMetadata();
    }

    private async Task ReloadMetadata()
    {
        ProjectCode = null;
        WorkItemType = null;
        if (Query is { Clause: AndClause andClause })
        {
            if (andClause.SubClauses.FirstOrDefault(sc => sc is ProjectClause) is ProjectClause projectClause)
            {
                ProjectCode = projectClause.ProjectCode;
            }

            if (andClause.SubClauses.FirstOrDefault(sc => sc is WorkItemTypeClause) is WorkItemTypeClause workItemTypeClause)
            {
                WorkItemType = workItemTypeClause.WorkItemType;
            }
        }

        if (ProjectCode is not null)
        {
            WorkItemTypes = (await WorkItemDescriptorService.GetWorkItemTypes(ProjectCode)).Types;
        }
        else
        {
            WorkItemTypes = null;
        }

        if (ProjectCode is not null && WorkItemType is not null)
        {
            WorkItemDescriptor = (await WorkItemDescriptorService.GetWorkItemDescriptorByWorkItemType(ProjectCode, WorkItemType));
        }
        else
        {
            WorkItemDescriptor = null;
        }
    }
    private Task AddPropertyClauseAsync(string propertyName, string? value)
    => AddClauseAsync(new ValueMatchClause(propertyName, value is null ? Array.Empty<string>() : new[] { value }, true));
    private Task AddWorkItemTypeClauseAsync(string projectCode, string workItemType)
    => AddClauseAsync(new WorkItemTypeClause(workItemType));

    private async Task AddClauseAsync(QueryClause clause)
    {
        Query = Query switch
        {
            null => new WorkItemsQuery(AndClause.Create(clause)),
            { Clause: AndClause andClause } => new WorkItemsQuery(new AndClause(andClause.SubClauses.Add(clause))),
            { Clause: var anyClause } => new WorkItemsQuery(AndClause.Create(anyClause, clause)),
        };

        await ReloadMetadata();
    }
    private async Task RemoveClauseAsync(QueryClause clause)
    {
        Query = Query switch
        {
            null => new WorkItemsQuery(AndClause.Create(clause)),
            { Clause: AndClause andClause } => new WorkItemsQuery(new AndClause(andClause.SubClauses.Remove(clause))),
            _ => Query,
        };

        await ReloadMetadata();
    }

    private async Task LoadValuesAsync(string propertyName)
    {
        var providedValues = await ValueProviderService.GetValuesForTemplateProperty(ProjectCode, WorkItemType, propertyName);

        ValuesForSelection = providedValues;
    }

    private async Task OnUpdateAsync()
    {
        Content = Query;
        await Dialog.CloseAsync(Query);
    }
}